#!/usr/local/bin/php
<?php

/*
 * Copyright (C) 2026 Brendan Bank
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Gateway exporter daemon. Runs as nobody (unprivileged).
 * Reads configuration from /usr/local/etc/gateway_exporter.conf
 * (generated by generate_config.php running as root via configd).
 * Talks to dpinger unix sockets directly â€” no config.xml access needed.
 */

define('CONFIG_PATH', '/usr/local/etc/gateway_exporter.conf');

openlog('gateway_exporter', LOG_DAEMON, LOG_LOCAL4);

$reconfigure = true;
$running = true;

pcntl_signal(SIGHUP, function () use (&$reconfigure) {
    $reconfigure = true;
});

pcntl_signal(SIGTERM, function () use (&$running) {
    $running = false;
});

pcntl_signal(SIGINT, function () use (&$running) {
    $running = false;
});

$interval = 15;
$output_path = '/var/tmp/node_exporter/gateway.prom';
$gw_config = [];

syslog(LOG_NOTICE, sprintf('Gateway exporter starting (pid=%d)', getmypid()));

while ($running) {
    pcntl_signal_dispatch();

    if (!$running) {
        break;
    }

    if ($reconfigure) {
        $json = @file_get_contents(CONFIG_PATH);
        if ($json === false) {
            syslog(LOG_ERR, 'Gateway exporter: cannot read config file, using defaults');
        } else {
            $config = json_decode($json, true);
            if ($config === null) {
                syslog(LOG_ERR, 'Gateway exporter: invalid config JSON, using defaults');
            } else {
                $interval = $config['interval'] ?? 15;
                if ($interval < 5 || $interval > 300) {
                    $interval = 15;
                }

                $output_path = $config['outputpath'] ?? '/var/tmp/node_exporter/gateway.prom';
                if (empty($output_path) || strpos($output_path, '..') !== false) {
                    $output_path = '/var/tmp/node_exporter/gateway.prom';
                }

                $gw_config = $config['gateways'] ?? [];
            }
        }

        syslog(LOG_NOTICE, sprintf(
            'Gateway exporter configured: interval=%ds, output=%s, gateways=%d',
            $interval,
            $output_path,
            count($gw_config)
        ));

        $reconfigure = false;
    }

    $metrics = collect_metrics($gw_config);
    $output = format_prometheus($metrics);

    // Atomic write: temp file + rename
    $tmp_path = $output_path . '.tmp.' . getmypid();
    if (@file_put_contents($tmp_path, $output) !== false) {
        @chmod($tmp_path, 0644);
        if (!@rename($tmp_path, $output_path)) {
            syslog(LOG_WARNING, 'Gateway exporter: failed to rename temp file to output path');
            @unlink($tmp_path);
        }
    } else {
        syslog(LOG_WARNING, 'Gateway exporter: failed to write temp file');
        @unlink($tmp_path);
    }

    sleep($interval);
}

// Cleanup on exit
syslog(LOG_NOTICE, 'Gateway exporter stopping');
@unlink($output_path);
closelog();

/**
 * Query dpinger sockets directly and collect gateway metrics.
 */
function collect_metrics(array $gw_config): array
{
    $metrics = [];
    $sockets = glob('/var/run/dpinger_*.sock');
    if ($sockets === false) {
        return $metrics;
    }

    foreach ($sockets as $sock_path) {
        if (!preg_match('/dpinger_(.+)\.sock$/', basename($sock_path), $matches)) {
            continue;
        }
        $gname = $matches[1];
        $gwcfg = $gw_config[$gname] ?? [];

        $entry = [
            'name' => $gname,
            'description' => $gwcfg['description'] ?? $gname,
            'monitor' => $gwcfg['monitor'] ?? '',
        ];

        // Skip force_down gateways
        if (!empty($gwcfg['force_down'])) {
            $entry['status_text'] = 'force_down';
            $entry['status_num'] = 0;
            $entry['delay_seconds'] = 0.0;
            $entry['stddev_seconds'] = 0.0;
            $entry['loss_ratio'] = 0.0;
            $metrics[] = $entry;
            continue;
        }

        // Connect to dpinger socket
        $fp = @stream_socket_client("unix://{$sock_path}", $errno, $errstr, 1);
        if (!$fp) {
            $entry['status_text'] = 'down';
            $entry['status_num'] = 0;
            $entry['delay_seconds'] = 0.0;
            $entry['stddev_seconds'] = 0.0;
            $entry['loss_ratio'] = 0.0;
            $metrics[] = $entry;
            continue;
        }

        $dinfo = '';
        while (!feof($fp)) {
            $dinfo .= fgets($fp, 1024);
        }
        fclose($fp);

        // dpinger returns: name latency_avg_us latency_stddev_us loss_pct
        $parts = explode(' ', trim($dinfo));
        if (count($parts) < 4) {
            $entry['status_text'] = 'pending';
            $entry['status_num'] = 5;
            $entry['delay_seconds'] = 0.0;
            $entry['stddev_seconds'] = 0.0;
            $entry['loss_ratio'] = 0.0;
            $metrics[] = $entry;
            continue;
        }

        $latency_avg_us = (int)$parts[1];
        $latency_stddev_us = (int)$parts[2];
        $loss_raw = (float)$parts[3];

        // Skip if dpinger hasn't collected data yet
        if ($latency_stddev_us == 0 && $loss_raw == 0) {
            $entry['status_text'] = !empty($gwcfg['monitor_disable']) ? 'none' : 'pending';
            $entry['status_num'] = !empty($gwcfg['monitor_disable']) ? 1 : 5;
            $entry['delay_seconds'] = 0.0;
            $entry['stddev_seconds'] = 0.0;
            $entry['loss_ratio'] = 0.0;
            $metrics[] = $entry;
            continue;
        }

        // Convert to milliseconds for threshold comparison (matches dpinger.inc logic)
        $latency_avg_ms = round($latency_avg_us / 1000, 1);
        $latency_stddev_ms = round($latency_stddev_us / 1000, 1);

        // Determine status using cached thresholds (mirrors dpinger.inc logic)
        $status = 'none';
        if (isset($gwcfg['losshigh']) && $gwcfg['losshigh'] !== null) {
            if ($latency_avg_ms > $gwcfg['latencyhigh'] || $loss_raw > $gwcfg['losshigh']) {
                $status = 'down';
            } elseif ($latency_avg_ms > $gwcfg['latencylow'] && $loss_raw > $gwcfg['losslow']) {
                $status = 'delay+loss';
            } elseif ($latency_avg_ms > $gwcfg['latencylow']) {
                $status = 'delay';
            } elseif ($loss_raw > $gwcfg['losslow']) {
                $status = 'loss';
            }
        }

        // Map status to numeric value
        switch ($status) {
            case 'none':
                $entry['status_num'] = 1;
                break;
            case 'down':
            case 'force_down':
                $entry['status_num'] = 0;
                break;
            case 'loss':
                $entry['status_num'] = 2;
                break;
            case 'delay':
                $entry['status_num'] = 3;
                break;
            case 'delay+loss':
                $entry['status_num'] = 4;
                break;
            default:
                $entry['status_num'] = 5;
                break;
        }

        $entry['status_text'] = $status;
        $entry['delay_seconds'] = $latency_avg_us / 1000000.0;
        $entry['stddev_seconds'] = $latency_stddev_us / 1000000.0;
        $entry['loss_ratio'] = $loss_raw / 100.0;

        $metrics[] = $entry;
    }

    return $metrics;
}

/**
 * Format metrics array as Prometheus exposition text.
 */
function format_prometheus(array $metrics): string
{
    $lines = [];

    $lines[] = '# HELP opnsense_gateway_status Gateway status (0=down, 1=up, 2=loss, 3=delay, 4=delay+loss, 5=unknown).';
    $lines[] = '# TYPE opnsense_gateway_status gauge';
    foreach ($metrics as $m) {
        $lines[] = sprintf(
            'opnsense_gateway_status{name="%s",description="%s"} %d',
            prom_escape($m['name']),
            prom_escape($m['description']),
            $m['status_num']
        );
    }

    $lines[] = '# HELP opnsense_gateway_delay_seconds Gateway round-trip time in seconds.';
    $lines[] = '# TYPE opnsense_gateway_delay_seconds gauge';
    foreach ($metrics as $m) {
        $lines[] = sprintf(
            'opnsense_gateway_delay_seconds{name="%s",description="%s"} %.6f',
            prom_escape($m['name']),
            prom_escape($m['description']),
            $m['delay_seconds']
        );
    }

    $lines[] = '# HELP opnsense_gateway_stddev_seconds Gateway RTT standard deviation in seconds.';
    $lines[] = '# TYPE opnsense_gateway_stddev_seconds gauge';
    foreach ($metrics as $m) {
        $lines[] = sprintf(
            'opnsense_gateway_stddev_seconds{name="%s",description="%s"} %.6f',
            prom_escape($m['name']),
            prom_escape($m['description']),
            $m['stddev_seconds']
        );
    }

    $lines[] = '# HELP opnsense_gateway_loss_ratio Gateway packet loss ratio (0.0-1.0).';
    $lines[] = '# TYPE opnsense_gateway_loss_ratio gauge';
    foreach ($metrics as $m) {
        $lines[] = sprintf(
            'opnsense_gateway_loss_ratio{name="%s",description="%s"} %.4f',
            prom_escape($m['name']),
            prom_escape($m['description']),
            $m['loss_ratio']
        );
    }

    $lines[] = '# HELP opnsense_gateway_info Gateway informational metric with status and monitor labels.';
    $lines[] = '# TYPE opnsense_gateway_info gauge';
    foreach ($metrics as $m) {
        $lines[] = sprintf(
            'opnsense_gateway_info{name="%s",description="%s",status="%s",monitor="%s"} 1',
            prom_escape($m['name']),
            prom_escape($m['description']),
            prom_escape($m['status_text']),
            prom_escape($m['monitor'])
        );
    }

    return implode("\n", $lines) . "\n";
}

/**
 * Escape a label value for Prometheus exposition format.
 * Backslash, double-quote, and newline must be escaped.
 */
function prom_escape($value)
{
    return str_replace(
        ['\\', '"', "\n"],
        ['\\\\', '\\"', '\\n'],
        (string)$value
    );
}
